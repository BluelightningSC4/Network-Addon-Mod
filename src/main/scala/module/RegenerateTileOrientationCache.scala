package metarules.module

import java.io.File
import metarules.meta.RotFlip
import resource.managed

/** Manages the tile orientation cache. The cache is necessary to maintain
  * information about non-standard orientations:
  * In some situations, a tile can appear in other absolute orientations than
  * its symmetries might suggest.
  */
object RegenerateTileOrientationCache {
  val cacheFile = new File("src/main/resources/tileOrientationCache.txt")

  def main(args: Array[String]): Unit = apply()

  /** Regenerate the cache from scratch.
    */
  def apply(): Unit = {
    val tileOrientationCache = collection.mutable.Map.empty[Int, Set[RotFlip]]
    compileMetarulesUntilStable(tileOrientationCache)
    storeCache(tileOrientationCache)
  }

  /** Repeatedly compiles the metarule code until the cache does not get changed anymore.
    */
  def compileMetarulesUntilStable(tileOrientationCache: collection.mutable.Map[Int, Set[RotFlip]]): Unit = {
    var j = 0
    var stabilized = false
    var previous: collection.immutable.Map[Int, Set[RotFlip]] = tileOrientationCache.toMap
    while (j < 3 && !stabilized) {
      LOGGER.info(s"> metarules compilation: iteration $j")
      j += 1
      CompileAllMetarules.compileMetarulesOnce(tileOrientationCache)
      val next = tileOrientationCache.toMap
      if (next == previous) {
        stabilized = true
      }
      previous = next
    }
  }

  def storeCache(cache: collection.Map[Int, Set[RotFlip]]): Unit = {
    for (printer <- managed(new java.io.PrintWriter(cacheFile, "UTF-8"))) {
      printer.println("; This file was generated by `sbt regenerateTileOrientationCache` and caches additional orientations of tiles.")
      printer.println("; Computing these orientations takes several runs of metarule compilation.")
      printer.println("; This file should be regenerated from time to time when the metarule code receives major updates.")
      for ((id, orientations) <- cache.toSeq.sortBy(_._1)) {
        printer.println(f"0x$id%08X," + orientations.mkString("+"))
      }
    }
  }

  def loadCache(): collection.mutable.Map[Int, Set[RotFlip]] = {
    managed(new java.util.Scanner(cacheFile, "UTF-8")) acquireAndGet { scanner =>
      val cache = collection.mutable.Map.empty[Int, Set[RotFlip]]
      while(scanner.hasNextLine()) {
        val line = scanner.nextLine()
        if (!line.startsWith(";") && line.nonEmpty) {
          val parts = line.split(",", 2)
          val id = java.lang.Long.parseLong(parts(0).substring(2), 16).toInt
          val orientations = RotFlip.ValueSet(parts(1).split("\\+").map(RotFlip.withName):_*)
          cache(id) = orientations
        }
      }
      cache
    }
  }

  /** Loads the cache and gives a warning at the end if it was changed.
    */
  def withCache(): resource.ManagedResource[collection.mutable.Map[Int, Set[RotFlip]]] = {
    var previous: collection.immutable.Map[Int, Set[RotFlip]] = null
    resource.makeManagedResource {  // opener
      val cache = loadCache()
      previous = cache.toMap
      cache
    } { cache =>  // closer
      assert(previous != null)
      if (previous != cache.toMap) {
        LOGGER.warning(s"The file ${cacheFile} is outdated. Rebuild it with `sbt regenerateTileOrientationCache` and commit the changes.")
      }
    } (List.empty)
  }
}
